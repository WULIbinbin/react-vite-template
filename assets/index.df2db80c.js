var B=Object.defineProperty;var J=(i,h,f)=>h in i?B(i,h,{enumerable:!0,configurable:!0,writable:!0,value:f}):i[h]=f;var R=(i,h,f)=>(J(i,typeof h!="symbol"?h+"":h,f),f);import{q as A,r as V}from"./vendor.84c21b23.js";import{s as W}from"./layout.cecaaf06.js";var K={exports:{}};const Q=A(W);var H={exports:{}};/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/(function(i){(function(){var h={}.hasOwnProperty;function f(){for(var m=[],$=0;$<arguments.length;$++){var c=arguments[$];if(!!c){var d=typeof c;if(d==="string"||d==="number")m.push(c);else if(Array.isArray(c)){if(c.length){var O=f.apply(null,c);O&&m.push(O)}}else if(d==="object")if(c.toString===Object.prototype.toString)for(var x in c)h.call(c,x)&&c[x]&&m.push(x);else m.push(c.toString())}}return m.join(" ")}i.exports?(f.default=f,i.exports=f):window.classNames=f})()})(H);var T="Invariant failed";function X(i,h){if(!i)throw new Error(T)}const Y=Object.freeze(Object.defineProperty({__proto__:null,default:X},Symbol.toStringTag,{value:"Module"})),Z=A(Y);(function(i){var h=Q,f=H.exports,m=V.exports,$=Z;function c(n){return n&&n.__esModule?n.default:n}function d(n,e,t,s){Object.defineProperty(n,e,{get:t,set:s,enumerable:!0,configurable:!0})}function O(n,e){return Object.keys(e).forEach(function(t){t==="default"||t==="__esModule"||n.hasOwnProperty(t)||Object.defineProperty(n,t,{enumerable:!0,get:function(){return e[t]}})}),n}d(i.exports,"Sortable",()=>$882b6d93070905b3$re_export$Sortable),d(i.exports,"Direction",()=>$882b6d93070905b3$re_export$Direction),d(i.exports,"DOMRect",()=>$882b6d93070905b3$re_export$DOMRect),d(i.exports,"GroupOptions",()=>$882b6d93070905b3$re_export$GroupOptions),d(i.exports,"MoveEvent",()=>$882b6d93070905b3$re_export$MoveEvent),d(i.exports,"Options",()=>$882b6d93070905b3$re_export$Options),d(i.exports,"PullResult",()=>$882b6d93070905b3$re_export$PullResult),d(i.exports,"PutResult",()=>$882b6d93070905b3$re_export$PutResult),d(i.exports,"SortableEvent",()=>$882b6d93070905b3$re_export$SortableEvent),d(i.exports,"SortableOptions",()=>$882b6d93070905b3$re_export$SortableOptions),d(i.exports,"Utils",()=>$882b6d93070905b3$re_export$Utils),d(i.exports,"ReactSortable",()=>P);function x(n){n.parentElement!==null&&n.parentElement.removeChild(n)}function N(n,e,t){const s=n.children[t]||null;n.insertBefore(e,s)}function S(n){n.forEach(e=>x(e.element))}function C(n){n.forEach(e=>{N(e.parentElement,e.element,e.oldIndex)})}function E(n,e){const t=v(n),s={parentElement:n.from};let r=[];switch(t){case"normal":r=[{element:n.item,newIndex:n.newIndex,oldIndex:n.oldIndex,parentElement:n.from}];break;case"swap":const a={element:n.item,oldIndex:n.oldIndex,newIndex:n.newIndex,...s},p={element:n.swapItem,oldIndex:n.newIndex,newIndex:n.oldIndex,...s};r=[a,p];break;case"multidrag":r=n.oldIndicies.map((b,g)=>({element:b.multiDragElement,oldIndex:b.index,newIndex:n.newIndicies[g].index,...s}));break}return z(r,e)}function k(n,e){const t=L(n,e);return M(n,t)}function L(n,e){const t=[...e];return n.concat().reverse().forEach(s=>t.splice(s.oldIndex,1)),t}function M(n,e,t,s){const r=[...e];return n.forEach(o=>{const l=s&&t&&s(o.item,t);r.splice(o.newIndex,0,l||o.item)}),r}function v(n){return n.oldIndicies&&n.oldIndicies.length>0?"multidrag":n.swapItem?"swap":"normal"}function z(n,e){return n.map(s=>({...s,item:e[s.oldIndex]})).sort((s,r)=>s.oldIndex-r.oldIndex)}function q(n){const{list:e,setList:t,children:s,tag:r,style:o,className:l,clone:a,onAdd:p,onChange:b,onChoose:g,onClone:_,onEnd:w,onFilter:y,onRemove:I,onSort:j,onStart:D,onUnchoose:U,onUpdate:ee,onMove:te,onSpill:ne,onSelect:se,onDeselect:oe,...G}=n;return G}const u={dragging:null};class P extends m.Component{constructor(e){super(e),this.ref=(0,m.createRef)();const t=[...e.list].map(s=>Object.assign(s,{chosen:!1,selected:!1}));e.setList(t,this.sortable,u),c($)(!e.plugins,`
Plugins prop is no longer supported.
Instead, mount it with "Sortable.mount(new MultiDrag())"
Please read the updated README.md at https://github.com/SortableJS/react-sortablejs.
      `)}componentDidMount(){if(this.ref.current===null)return;const e=this.makeOptions();c(h).create(this.ref.current,e)}componentDidUpdate(e){e.disabled!==this.props.disabled&&this.sortable&&this.sortable.option("disabled",this.props.disabled)}render(){const{tag:e,style:t,className:s,id:r}=this.props,o={style:t,className:s,id:r},l=!e||e===null?"div":e;return(0,m.createElement)(l,{ref:this.ref,...o},this.getChildren())}getChildren(){const{children:e,dataIdAttr:t,selectedClass:s="sortable-selected",chosenClass:r="sortable-chosen",dragClass:o="sortable-drag",fallbackClass:l="sortable-falback",ghostClass:a="sortable-ghost",swapClass:p="sortable-swap-highlight",filter:b="sortable-filter",list:g}=this.props;if(!e||e==null)return null;const _=t||"data-id";return m.Children.map(e,(w,y)=>{if(w===void 0)return;const I=g[y]||{},{className:j}=w.props,D=typeof b=="string"&&{[b.replace(".","")]:!!I.filtered},U=c(f)(j,{[s]:I.selected,[r]:I.chosen,...D});return(0,m.cloneElement)(w,{[_]:w.key,className:U})})}get sortable(){const e=this.ref.current;if(e===null)return null;const t=Object.keys(e).find(s=>s.includes("Sortable"));return t?e[t]:null}makeOptions(){const e=["onAdd","onChoose","onDeselect","onEnd","onRemove","onSelect","onSpill","onStart","onUnchoose","onUpdate"],t=["onChange","onClone","onFilter","onSort"],s=q(this.props);return e.forEach(o=>s[o]=this.prepareOnHandlerPropAndDOM(o)),t.forEach(o=>s[o]=this.prepareOnHandlerProp(o)),{...s,onMove:(o,l)=>{const{onMove:a}=this.props,p=o.willInsertAfter||-1;if(!a)return p;const b=a(o,l,this.sortable,u);return typeof b>"u"?!1:b}}}prepareOnHandlerPropAndDOM(e){return t=>{this.callOnHandlerProp(t,e),this[e](t)}}prepareOnHandlerProp(e){return t=>{this.callOnHandlerProp(t,e)}}callOnHandlerProp(e,t){const s=this.props[t];s&&s(e,this.sortable,u)}onAdd(e){const{list:t,setList:s,clone:r}=this.props,o=[...u.dragging.props.list],l=E(e,o);S(l);const a=M(l,t,e,r).map(p=>Object.assign(p,{selected:!1}));s(a,this.sortable,u)}onRemove(e){const{list:t,setList:s}=this.props,r=v(e),o=E(e,t);C(o);let l=[...t];if(e.pullMode!=="clone")l=L(o,l);else{let a=o;switch(r){case"multidrag":a=o.map((p,b)=>({...p,element:e.clones[b]}));break;case"normal":a=o.map(p=>({...p,element:e.clone}));break;case"swap":default:c($)(!0,`mode "${r}" cannot clone. Please remove "props.clone" from <ReactSortable/> when using the "${r}" plugin`)}S(a),o.forEach(p=>{const b=p.oldIndex,g=this.props.clone(p.item,e);l.splice(b,1,g)})}l=l.map(a=>Object.assign(a,{selected:!1})),s(l,this.sortable,u)}onUpdate(e){const{list:t,setList:s}=this.props,r=E(e,t);S(r),C(r);const o=k(r,t);return s(o,this.sortable,u)}onStart(){u.dragging=this}onEnd(){u.dragging=null}onChoose(e){const{list:t,setList:s}=this.props,r=t.map((o,l)=>{let a=o;return l===e.oldIndex&&(a=Object.assign(o,{chosen:!0})),a});s(r,this.sortable,u)}onUnchoose(e){const{list:t,setList:s}=this.props,r=t.map((o,l)=>{let a=o;return l===e.oldIndex&&(a=Object.assign(a,{chosen:!1})),a});s(r,this.sortable,u)}onSpill(e){const{removeOnSpill:t,revertOnSpill:s}=this.props;t&&!s&&x(e.item)}onSelect(e){const{list:t,setList:s}=this.props,r=t.map(o=>Object.assign(o,{selected:!1}));e.newIndicies.forEach(o=>{const l=o.index;if(l===-1){console.log(`"${e.type}" had indice of "${o.index}", which is probably -1 and doesn't usually happen here.`),console.log(e);return}r[l].selected=!0}),s(r,this.sortable,u)}onDeselect(e){const{list:t,setList:s}=this.props,r=t.map(o=>Object.assign(o,{selected:!1}));e.newIndicies.forEach(o=>{const l=o.index;l!==-1&&(r[l].selected=!0)}),s(r,this.sortable,u)}}R(P,"defaultProps",{clone:e=>e});var F={};O(i.exports,F)})(K);export{K as d};
